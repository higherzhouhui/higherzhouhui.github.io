<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Mark Otto, Jacob Thornton, and Bootstrap contributors">
  <meta name="generator" content="Hugo 0.88.1">
  <title>面试精题</title>

  <link rel="canonical" href="https://getbootstrap.com/docs/5.1/examples/dashboard/">

  <!-- Bootstrap core CSS -->
  <link href="../css/bootstrap.min.css" rel="stylesheet">

  <style>
    .bd-placeholder-img {
      font-size: 1.125rem;
      text-anchor: middle;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    @media (min-width: 768px) {
      .bd-placeholder-img-lg {
        font-size: 3.5rem;
      }
    }

    a {
      text-decoration: none;
    }

    .sidebar {
      overflow: auto;
    }
  </style>


  <!-- Custom styles for this template -->
  <link href="../css/dashboard.css" rel="stylesheet">
</head>

<body>
  <div class="container-fluid">
    <div class="row">
      <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
        <div class="position-sticky pt-3">
          <ul class="nav flex-column">
            <li class="nav-item">
              <a class="nav-link h4" aria-current="page" href="/">
                <span data-feather="home"></span>
                首页->面试题
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link h6" aria-current="page" href="#network">
                <span data-feather="home"></span>
                计算器网络
              </a>
              <ul>
                <li>
                  <a class="nav-link" aria-current="page" href="#newwork">
                    <span data-feather="home"></span>
                    HTTP 和 HTTPS
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#get">
                    <span data-feather="home"></span>
                    GET与POST的区别
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#zchttp">
                    <span data-feather="home"></span>
                    HTTP报文的组成成分
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#https">
                    <span data-feather="home"></span>
                    https 的基本概念
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#tcp">
                    <span data-feather="home"></span>
                    TCP/IP网络模型
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#ky">
                    <span data-feather="home"></span>
                    HTTP 请求跨域问题
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#cookie">
                    <span data-feather="home"></span>
                    Cookie、sessionStorage、localStorage 的区别
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#ztm">
                    <span data-feather="home"></span>
                    HTTP状态码及常见状态码
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#huancun">
                    <span data-feather="home"></span>
                    浏览器的缓存机制 强制缓存 && 协商缓存
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#clj">
                    <span data-feather="home"></span>
                    客户端与服务端长连接的几种方式
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#jiami">
                    <span data-feather="home"></span>
                    非对称加密RSA
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#xss">
                    <span data-feather="home"></span>
                    理解xss，csrf，ddos攻击原理以及避免方式
                  </a>
                </li>
              </ul>
            </li>
            <li class="nav-item">
              <a class="nav-link h6" aria-current="page" href="#brower">
                <span data-feather="home"></span>
                浏览器
              </a>
              <ul>
                <li>
                  <a class="nav-link" aria-current="page" href="#url">
                    <span data-feather="home"></span>
                    从输入URL到页面加载的全过程
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#bgn">
                    <span data-feather="home"></span>
                    浏览器的主要功能
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#bgzyl">
                    <span data-feather="home"></span>
                    浏览器的工作原理
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#bzcbf">
                    <span data-feather="home"></span>
                    浏览器的主要组成部分是什么？
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#bxuanran">
                    <span data-feather="home"></span>
                    浏览器是如何渲染UI的？
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#bchonghui">
                    <span data-feather="home"></span>
                    浏览器重绘与重排的区别？
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#cfchongpai">
                    <span data-feather="home"></span>
                    如何触发重排和重绘？
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#bmchongpai">
                    <span data-feather="home"></span>
                    如何避免重绘或者重排？
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#jingcheng">
                    <span data-feather="home"></span>
                    说下进程、线程和协程
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#ljhs">
                    <span data-feather="home"></span>
                    JS垃圾回收机制
                  </a>
                </li>
              </ul>
            </li>
            <li class="nav-item">
              <a class="nav-link h6" aria-current="page" href="#react">
                <span data-feather="home"></span>
                TypeScript
              </a>
              <ul>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript1">
                    <span data-feather="home"></span>
                    TypeScript 和 JavaScript 的区别是什么
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript3">
                    <span data-feather="home"></span>
                    为什么要用 TypeScript 
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript4">
                    <span data-feather="home"></span>
                    TypeScript 和 JavaScript 哪个更好
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript5">
                    <span data-feather="home"></span>
                    什么是泛型
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript6">
                    <span data-feather="home"></span>
                    TS中的类
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript7">
                    <span data-feather="home"></span>
                    什么是构造函数，构造函数作用是什么
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript8">
                    <span data-feather="home"></span>
                    实例化是什么
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript9">
                    <span data-feather="home"></span>
                   方法重写是什么
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript10">
                    <span data-feather="home"></span>
                    什么是可索引类型接口
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript11">
                    <span data-feather="home"></span>
                    什么是函数类型接口
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript12">
                    <span data-feather="home"></span>
                    什么是类类型接口
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript13">
                    <span data-feather="home"></span>
                    什么是混合类型接口
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript14">
                    <span data-feather="home"></span>
                    never 和 void 的区别
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#typescript15">
                    <span data-feather="home"></span>
                    TS的学前基础
                  </a>
                </li>
              </ul>
            </li>
          </ul>
        </div>
      </nav>
      <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
        <div class="pt-3 pb-3 mb-3">
          <h1 class="h2 border-bottom mb-4 pb-2">常问面试题</h1>
          <a href="#network" name="network" class="h4">HTTP 和 HTTPS</a>
          <h5>HTTP 的基本概念</h5>
          <p class="bg-light">http: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端`请求和应答的标准（TCP）`，用于从 WWW 服务器传输超文本到本地浏览器的`超文本传输协议`。</p>
          <h5>HTTP工作原理</h5>
          HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。客户端向服务器发送一个请求报文，服务器以一个状态行作为响应。
          <h5 class="mt-2">HTTP请求/响应的步骤</h5>
          <ol>
            <li>客户端连接到Web服务器</li>
            <li>发送HTTP请求</li>
            <li>服务器接受请求并返回HTTP响应</li>
            <li>释放TCP连接</li>
            <li>客户端（浏览器）解析HTML内容</li>
          </ol>
          <p>记忆口诀：连接发送加响应，释放解析整过程。</p>
          <h5>HTTP 的 5 种方法</h5>
          <ul>
            <li>- GET---获取资源</li>
            <li>- POST---传输资源</li>
            <li>- PUT---更新资源</li>
            <li>- DELETE---删除资源</li>
            <li>- HEAD---获取报文首部</li>
          </ul>
          <hr />
          <a href="#get" name="get" class="h4">GET与POST的区别</a>
          <ol>
            <li>浏览器回退表现不同GET在浏览器回退时是无害的，而POST会再次提交请求</li>
            <li>浏览器对请求地址的处理不同GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置</li>
            <li>浏览器对响应的处理不同ET请求参数会被完整的保留在浏览器历史记录里，而POST中的参数不会被保留</li>
            <li>参数大小不同.GET请求在URL中传送的参数是有长度的限制，而POST没有限制</li>
            <li>安全性不同.GET参数通过URL传递，会暴露，不安全；POST放在Request Body中，相对更安全</li>
            <li>针对数据操作的类型不同.GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写</li>
          </ol>
          <hr />
          <a href="#zchttp" name="zchttp" class="h4">HTTP报文的组成成分</a>
          <ul>
            <li>请求报文{ 请求行、请求头、空行、请求体 } </li>
            <li>请求行：{http方法、页面地址、http协议、http版本}</li>
            <li>响应报文{ 状态行、响应头、空行、响应体 }</li>
          </ul>
          <h5>Request Header:</h5>
          <ol>
            <li>GET /sample.Jsp HTTP/1.1  //请求行</li>
            <li>Host:  www.uuid.online/ //请求的目标域名和端口号</li>
            <li>Origin: http://localhost:8081/ //请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）</li>
            <li>Referer: https://localhost:8081/link?query=xxxxx //请求资源的完整URI</li>
            <li>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
              Chrome/67.0.3396.99 Safari/537.36 //浏览器信息</li>
            <li>Cookie:  BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0  //当前域名下的Cookie</li>
            <li>Accept: text/html,image/apng  //代表客户端希望接受的数据类型是html或者是png图片类型 </li>
            <li>Accept-Encoding: gzip, deflate  //代表客户端能支持gzip和deflate格式的压缩</li>
            <li>Accept-Language: zh-CN,zh;q=0.9  //代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)
            </li>
            <li>Connection: keep-alive  //告诉服务器，客户端需要的tcp连接是一个长连接</li>
          </ol>
          <h5>Response Header:</h5>
          <ol>
            <li>HTTP/1.1 200 OK  // 响应状态行</li>
            <li>Date:  Mon, 30 Jul 2018 02:50:55 GMT  //服务端发送资源时的服务器时间</li>
            <li>Expires:  Wed, 31 Dec 1969 23:59:59
              GMT //比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页</li>
            <li>Cache-Control:  no-cache  //
              现在最多使用的控制缓存的方式，会和服务器进行缓存验证，具体见[博文”Cache-Control“](https://www.cnblogs.com/amiezhang/p/9389537.html)</li>
            <li>etag:  "fb8ba2f80b1d324bb997cbe188f28187-ssl-df"  //
              一般是[Nginx静态服务器](http://www.t086.com/article/5207)发来的静态文件签名，浏览在没有“Disabled
              cache”情况下，接收到etag后，同一个url第二次请求就会自动带上“If-None-Match”</li>
            <li>Last-Modified:  Fri, 27 Jul 2018 11:04:55
              GMT //是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容</li>
            <li>Content-Type:  text/html;
              charset=utf-8  //如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码</li>
            <li>Content-Encoding:  gzip  //告诉客户端，应该采用gzip对资源进行解码</li>
            <li>Connection:  keep-alive  //告诉客户端服务器的tcp连接也是一个长连接</li>
          </ol>
          <hr />
          <a href="#https" name="https" class="h4">https 的基本概念</a>
          <p>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。</p>
          <p>https 协议的作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p>
          <h5>http 和 https 的区别？</h5>
          <ol>
            <li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li>
            <li>Https 协议需要 ca 证书，费用较高。</li>
            <li>使用不同的链接方式，端口也不同，一般，http 协议的端口为 80，https 的端口为 443。</li>
            <li>http 的连接很简单，是无状态的。</li>
          </ol>
          <p class="text-danger">记忆口诀：明文传输超文本，安全等级各不同。CA证书费用高，无状连接端难同。</p>
          <h5>https 协议的工作原理</h5>
          <p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
          <ol>
            <li>客户端使用 https url 访问服务器，则要求 web 服务器`建立 ssl 链接`。</li>
            <li>web 服务器接收到客户端的请求之后，会`将网站的证书（证书中包含了公钥），传输给客户端`。</li>
            <li>客户端和 web 服务器端开始`协商 SSL 链接的安全等级`，也就是加密等级。</li>
            <li>客户端浏览器通过双方协商一致的安全等级，`建立会话密钥`，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
            <li>web 服务器`通过自己的私钥解密出会话密钥`。</li>
            <li>web 服务器`通过会话密钥加密与客户端之间的通信`。</li>
          </ol>
          <p>记忆口诀：一连二传三协商，四建五得六使用。</p>

          <h5>https 协议的优缺点</h5>
          <ol>
            <li>HTTPS 协议要比 http 协议`安全`，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</li>
            <li>https 握手阶段比较`费时`，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li>
            <li>https `缓存`不如 http 高效，会增加数据开销。</li>
            <li>SSL 证书也需要钱，功能越强大的`证书费`用越高。</li>
            <li>SSL 证书需要绑定 `IP`，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li>
          </ol>
          <hr />
          <a href="#tcp" name="tcp" class="h4">TCP/IP网络模型</a>
          <p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p>
          <ul>
            <li>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li>
            <li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li>
            <li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li>
            <li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li>
          </ul>
          <h5>TCP三次握手</h5>
          <ol>
            <li>第一次握手：`建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认`；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
            <li>第二次握手：`服务器收到syn包并确认客户的SYN`（ack=j+1），`同时也发送一个自己的SYN包`（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
            <li>第三次握手：`客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）`，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
          </ol>
          <p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p>

          <h5>TCP 四次挥手</h5>
          <ol>
            <li>
              `客户端进程发出连接释放报文`，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。
              TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
            <li>
              服务器收到连接释放报文，发出确认报文`，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
            </li>
            <li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</li>
            <li>
              服务器将最后的数据发送完毕后，就向客户端发送连接释放报文`，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
            </li>
            <li>
              客户端收到服务器的连接释放报文后，必须发出确认`，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
            </li>
            <li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
          </ol>
          <h5>TCP和UDP的区别</h5>
          <ol>
            <li>TCP是面向`连接`的，而UDP是面向无连接的。</li>
            <li>TCP仅支持`单播传输`，UDP 提供了单播，多播，广播的功能。</li>
            <li>TCP的三次握手保证了连接的`可靠性`; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。
            </li>
            <li>UDP的`头部开销`比TCP的更小，数据`传输速率更高`，`实时性更好`。</li>
          </ol>
          <hr />
          <a href="#ky" name="ky" class="h4">HTTP 请求跨域问题</a>
          <h6>1. 跨域的原理</h6>
          <ul>
            <li>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的`同源策略`造成的</li>
            <li>同源策略,是浏览器对 JavaScript 实施的安全限制，只要`协议、域名、端口`有任何一个不同，都被当作是不同的域</li>
            <li>跨域原理，即是通过各种方式，`避开浏览器的安全限制`。</li>
          </ul>

          <h6>2. 解决方案</h6>

          <p>
            >最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有
            windows.postMessage()</p>

          <h6>JSONP</h6>
          <p>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js
            代码，在 src 中进行了调用，这样实现了跨域。</p>
          <ol>
            步骤：
            <li>去创建一个script标签</li>
            <li>script的src属性设置接口地址</li>
            <li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li>
            <li>通过定义函数名去接受返回的数据</li>
          </ol>
          js<br />
          //动态创建 script<br />
          var script = document.createElement('script');<br />

          // 设置回调函数<br />
          function getData(data) {<br />
          console.log(data);<br />
          }<br />

          //设置 script 的 src 属性，并设置请求地址<br />
          script.src = 'http://localhost:3000/?callback=getData';<br />

          // 让 script 生效<br />
          document.body.appendChild(script);<br />
          <h6>JSONP 的缺点</h6>
          <p>JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p>

          - document.domain 基础域名相同 子域名不同<br />
          - window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name<br />
          - CORS CORS(Cross-origin resource sharing)跨域资源共享<br />
          服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求<br />
          - proxy代理 目前常用方式<br />
          - window.postMessage() 利用h5新特性 window.postMessage()<br />
          - Websocket
          <hr />
          <a href="#cookie" name="cookie" class="h4">Cookie、sessionStorage、localStorage 的区别</a>
          <p>相同点：存储在客户端</p>
          <p>不同点：</p>
          <ol>
            <li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li>
            <li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li>
            <li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li>
          </ol>
          <a href="#ztm" name="ztm" class="h4">HTTP状态码及常见状态码</a>
          <p>HTTP状态码</p>
          1xx：指示信息类，表示请求已接受，继续处理<br />
          2xx：指示成功类，表示请求已成功接受<br />
          3xx：指示重定向，表示要完成请求必须进行更近一步的操作<br />
          4xx：指示客户端错误，请求有语法错误或请求无法实现<br />
          5xx：指示服务器错误，服务器未能实现合法的请求<br />
          <p>常见状态码</p>
          200 OK：客户端请求成功
          <br />301 Moved Permanently：所请求的页面已经永久重定向至新的URL
          <br />302 Found：所请求的页面已经临时重定向至新的URL
          <br />304 Not Modified 未修改。
          <br />403 Forbidden：对请求页面的访问被禁止
          <br />404 Not Found：请求资源不存在
          <br />500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用
          <br />503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常

          1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码<br />
          100继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分<br />
          101切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换<br />

          2xx（成功）表示成功处理了请求的状态码<br />
          `200`成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页<br />
          201已创建 请求成功并且服务器创建了新的资源<br />
          202已接受 服务器已接受请求，但尚未处理<br />
          203非授权信息 服务器已经成功处理了请求，但返回的信息可能来自另一来源<br />
          204无内容 服务器成功处理了请求，但没有返回任何内容<br />
          205重置内容 服务器成功处理了请求，但没有返回任何内容<br />

          3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向<br />
          300多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择<br />
          `301`永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置<br />
          `302`临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求<br />
          303查看其它位置 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码<br />
          `304`未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容<br />
          305使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理<br />
          `307`临时性重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求<br />

          4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理<br />
          `400`错误请求 服务器不理解请求的语法<br />
          `401`未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应<br />
          `403`禁止 服务器拒绝请求<br />
          `404`未找到 服务器找不到请求的网页<br />
          405方法禁用 禁用请求中指定的方法<br />
          406不接受 无法使用请求的内容特性响应请求的网页<br />
          `407`需要代理授权 此状态码与401（未授权）类似，但指定请求者应当授权使用代理<br />
          `408`请求超时 服务器等候请求时发生超时<br />
          410已删除 如果请求的资源已永久删除，服务器就会返回此响应<br />
          `413`请求实体过大 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力<br />
          `414`请求的URI过长 请求的URI（通常为网址）过长，服务器无法处理<br />


          5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错<br />
          `500`服务器内部错误 服务器遇到错误，无法完成请求<br />
          501尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码<br />
          `502`错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应<br />
          `503`服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态<br />
          `504`网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求<br />
          505HTTP版本不受支持 服务器不支持请求中所用的HTTP协议版本<br />
          <p>介绍下304过程</p>
          a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control:
          max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。

          <br /> b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。

          <br /> c.
          协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。
          <p><a href="#huancun" name="huancun" class="h4">浏览器的缓存机制 强制缓存 && 协商缓存</a></p>
          浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 <br />
          服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：
          <br />
          - 浏览器每次发起请求，都会`先在浏览器缓存中查找该请求的结果以及缓存标识`<br />
          - 浏览器每次拿到返回的请求结果都会`将该结果和缓存标识存入浏览器缓存中`<br />
          <br />
          以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是`强制缓存`和`协商缓存`。
          <br />
          - 强制缓存<br />

          `强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。`当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是
          `Expires` 和 `Cache-Control`，其中Cache-Control优先级比Expires高。
          <br />
          强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：
          <br />
          1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。<br />
          1. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。<br />
          1. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果<br />
          <br />
          - 协商缓存<br />
          <br />
          `协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程`，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：`Last-Modified
          / If-Modified-Since` 和 `Etag / If-None-Match`，其中Etag / If-None-Match的优先级比Last-Modified /<br />
          If-Modified-Since高。协商缓存主要有以下两种情况：<br />

          1. 协商缓存生效，返回304<br />
          1. 协商缓存失效，返回200和请求结果结果<br />

          <hr /> 粘包问题分析与对策

          TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。<br />

          粘包出现原因<br />

          简单得说，在流传输中出现，UDP不会出现粘包，因为它有消息边界<br />

          粘包情况有两种，一种是`粘在一起的包都是完整的数据包`，另一种情况是`粘在一起的包有不完整的包`。<br />

          为了避免粘包现象，可采取以下几种措施：<br />

          （1）对于发送方引起的粘包现象，用户可通过编程设置来避免，`TCP提供了强制数据立即传送的操作指令push`，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；

          <br />（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、`提高接收进程优先级等措施`，使其及时接收数据，从而尽量避免出现粘包现象；

          <br />（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。`分包多发`。

          <br />以上提到的三种措施，都有其不足之处。

          <br /> （1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。

          <br />（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。

          <br />（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。

          <br /> 一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。


          <hr />
          <p><a href="#clj" name="clj" class="h4">客户端与服务端长连接的几种方式</a></p>

          <h6>1. ajax 轮询</h6>
          实现原理：ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。<br />

          优点：可实现基础（指间隔时间较短）的数据更新。<br />

          缺点：这种方法也只是尽量的模拟即时传输，但并非真正意义上的即时通讯，很有可能出现客户端请求时，服务端数据并未更新。或者服务端数据已更新，但客户端未发起请求。导致多次请求资源浪费，效率低下。【`数据更新不及时，效率低下`】<br />

          <h6>2. long poll 长轮询</h6>

          实现原理：<br />
          long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询。在 HTTP1.0
          中客户端可以设置请求头<br />
          Connection:keep-alive，服务端收到该请求头之后知道这是一个长连接，在响应报文头中也添加 Connection:keep-alive。客户端收到之后表示长连接建立完成，可以继续发送其他的请求。在
          HTTP1.1 中默认使用了 Connection:keep-alive 长连接。<br />

          优点：减少客户端的请求，降低无效的网络传输，保证每次请求都有数据返回，不会一直占用线程。<br />

          缺点：无法处理高并发，当客户端请求量大，请求频繁时对服务器的处理能力要求较高。服务器一直保持连接会消耗资源，需要同时维护多个线程，服务器所能承载的 TCP
          连接数是有上限的，这种轮询很容易把连接数顶满。每次通讯都需要客户端发起，服务端不能主动推送。【`无法处理高并发，消耗服务器资源严重，服务端不能主动推送`】<br />

          <h6>3. iframe 长连接</h6>

          实现原理：<br />
          在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。<br />

          优点：消息及时传输。<br />

          缺点：`消耗服务器资源`。<br />

          <h6>4. WebSocket</h6>

          实现原理：<br />
          Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。<br />

          Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。<br />

          Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。<br />

          优点：<br />
          双向通信。客户端和服务端双方都可以主动发起通讯。<br />
          没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。<br />
          数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。<br />
          传输效率高。因为只需要一次连接，所以数据传输效率高。<br />

          缺点：<br />
          长连接需要后端处理业务的代码更稳定，推送消息相对复杂；<br />
          长连接受网络限制比较大，需要处理好重连。<br />
          兼容性，WebSocket 只支持 IE10 及其以上版本。<br />
          服务器长期维护长连接需要一定的成本，各个浏览器支持程度不一；<br />
          成熟的 HTTP 生态下有大量的组件可以复用，WebSocket 则没有，遇到异常问题难以快速定位快速解决。【需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小】


          <h6>利用Socket建立网络连接的步骤</h6>

          建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br />

          套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。<br />

          　　1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。<br />

          　　2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。<br />

          　　为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br />

          　　3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。<br />

          而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。<br />

          <hr />
          <p><a href="#jiami" name="jiami" class="h4">非对称加密RSA</a></p>

          简介： <br />
          1. 对称加密算法又称现代加密算法。  <br />
          2. 非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。  <br />
          3. 非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey)  <br />
          4. 公开密钥和私有密钥是一对 <br />

          如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。  <br />
          如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。 <br />

          特点：  <br />
          算法强度复杂，安全性依赖于算法与密钥。  <br />
          加密解密速度慢。 <br />

          与对称加密算法的对比：  <br />
          对称加密只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。  <br />
          非对称加密有两种密钥，其中一个是公开的。 <br />

          RSA应用场景：  <br />
          由于RSA算法的加密解密速度要比对称算法速度慢很多，在实际应用中，通常采取  <br />
          数据本身的加密和解密使用对称加密算法(AES)。 用RSA算法加密并传输对称算法所需的密钥。 <br />
          <hr />
          <p><a href="#xss" name="xss" class="h4">理解xss，csrf，ddos攻击原理以及避免方式</a></p>

          `XSS`(`Cross-Site Scripting`，跨站脚本攻击)是一种代码注入攻击。<br />
          攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取
          `cookie，session tokens`，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。<br />

          `CSRF`（`Cross-site requestforgery`）<br />
          跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。<br />

          XSS避免方式：<br />

          1. `url`参数使用`encodeURIComponent`方法转义<br />
          2. 尽量不是有`InnerHtml`插入`HTML`内容<br />
          3. 使用特殊符号、标签转义符。<br />

          `CSRF`避免方式：<br />

          1. 添加验证码<br />

          2. 使用token<br />

          - 服务端给用户生成一个token，加密后传递给用户<br />
          - 用户在提交请求时，需要携带这个token<br />
          - 服务端验证token是否正确<br />

          `DDoS`又叫分布式拒绝服务，全称 `Distributed Denial of Service`，其原理就是利用大量的请求造成资源过载，导致服务不可用。<br />

          `DDos`避免方式：<br />

          1. 限制单IP请求频率。<br />
          2. 防火墙等防护设置禁止`ICMP`包等<br />
          3. 检查特权端口的开放<br />
          <hr />
          <p><a href="#url" name="url" class="h4">从输入URL到页面加载的全过程</a></p>
          <ol>
            <li>首先在浏览器中输入URL</li>
            <li>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。
              <p>
                浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
                <br /> 操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；
                <br /> 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
                <br /> ISP缓存：若上述均失败，继续向ISP搜索。
              </p>
            </li>
            <li>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。`DNS服务器是基于UDP的，因此会用到UDP协议`。</li>
            <li>建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</li>
            <li>发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器</li>
            <li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</li>
            <li>关闭TCP连接：通过四次挥手释放TCP连接</li>
            <li>浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：
              <p>
                构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
                <br />构建CSS规则树：生成CSS规则树（CSS Rule Tree）
                <br />构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
                <br />布局（Layout）：计算出每个节点在屏幕中的位置
                <br />绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。
              </p>
            </li>
            <li>JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
              <p>
                创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM
                <br />Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。
                <br />加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译
                <br />预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。
                <br />解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。
              </p>
            </li>
          </ol>
          <hr />
          <p><a href="#bgn" name="bgn" class="h4">浏览器的主要功能</a></p>

          浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。<br />
          <hr />
          <p><a href="#bgzyl" name="bgzyl" class="h4">浏览器的工作原理</a></p>
          渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。<br />
          然后进行如下所示的基本流程：<br />
          <hr />
          <p><a href="#bzcbf" name="bzcbf" class="h4">浏览器的主要组成部分是什么？</a></p>
          1. 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。<br />
          2. 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。<br />
          3. 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。<br />
          4. 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。<br />
          5. 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。<br />
          6. JavaScript 解释器。用于解析和执行 JavaScript 代码。<br />
          7. 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。<br />
          值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。<br />
          <hr />
          <p><a href="#bxuanran" name="bxuanran" class="h4">浏览器是如何渲染UI的？</a></p>

          1. 浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree<br />
          2. 与此同时，进行CSS解析，生成Style Rules<br />
          3. 接着将DOM Tree与Style Rules合成为 Render Tree<br />
          4. 接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标<br />
          5. 随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来<br />
          <hr /> DOM Tree是如何构建的？<br />
          1. 转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串<br />
          2. 生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens<br />
          3. 构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope<br />
          4. 生成DOM Tree: 通过node包含的指针确定的关系构建出DOM Tree<br />
          <hr />
          <p><a href="#bchonghui" name="bchonghui" class="h4">浏览器重绘与重排的区别？</a></p>

          - `重排/回流（Reflow）`：当`DOM`的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。<br />
          - `重绘(Repaint)`: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变<br />

          单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分<br />

          重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。<br />

          『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。<br />

          <hr />
          <p><a href="#bcfchongpai" name="bcfchongpai" class="h4">如何触发重排和重绘？</a></p>
          <h5>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</h5>
          <ul>
            <li>添加、删除、更新DOM节点</li>
            <li>通过display: none隐藏一个DOM节点-触发重排和重绘</li>
            <li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li>
            <li>移动或者给页面中的DOM节点添加动画</li>
            <li>添加一个样式表，调整样式属性</li>
            <li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li>
          </ul>
          <p><a href="#bmchongpai" name="bmchongpai" class="h4">如何避免重绘或者重排？</a></p>
          <ol>
            <li>`集中改变样式`，不要一条一条地修改 DOM 的样式。</li>
            <li>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</li>
            <li>为动画的 HTML 元件使用 `fixed` 或 `absoult` 的 `position`，那么修改他们的 CSS 是不会 reflow 的。</li>
            <li>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</li>
            <li>尽量只修改`position：absolute`或`fixed`元素，对其他元素影响不大</li>
            <li>动画开始`GPU`加速，`translate`使用`3D`变化</li>
            <li>提升为合成层</li>
          </ol>
          <h6>将元素提升为合成层有以下优点：</h6>
          <ol>
            <li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
            <li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
            <li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
          </ol>
          <p class="text-danger">提升合成层的最好方式是使用 CSS 的 will-change 属性</p>
          <hr />
          <p><a href="#jincheng" name="jingcheng" class="h4">说下进程、线程和协程</a></p>
          进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，`是操作系统进行资源分配和调度的一个独立单位`，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。<br />

          线程是程序执行中一个单一的顺序控制流程，是`程序执行流的最小单元`，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。<br />

          协程，英文Coroutines，是一种`基于线程之上，但又比线程更加轻量级的存在`，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。<br />

          进程和线程的区别与联系<br />

          <h5>区别</h5>

          调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；<br />

          并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；<br />

          拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。<br />

          系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<br />

          <h5>联系</h5>

          一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；<br />

          资源分配给进程，同一进程的所有线程共享该进程的所有资源；<br />

          处理机分给线程，即真正在处理机上运行的是线程；<br />

          线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。<br />

          <p class="text-success">传送门 ☞ [# 一文搞懂进程、线程、协程及JS协程的发展](https://juejin.cn/post/7005465381791875109)</p>
          <p class="text-success">[☞了解更多](http://www.360doc.com/content/20/0417/14/32196507_906628857.shtml)</p>
          <p class="text-success">关于浏览器传送门 ☞[# 深入了解现代 Web 浏览器](https://juejin.cn/post/6993095345576083486)</p>
          <h5>进程间的通信方式</h5>
          `进程通信`：<br />
          每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

          <br />进程间的通信方式：管道、有名管道、信号、消息队列、共享内存、信号量、socket

          <br /> `匿名管道( pipe )`： 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

          <br />`高级管道(popen)`：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。

          <br />`有名管道 (named pipe) `： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

          <br />`消息队列( message queue )` ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

          <br /> `信号量( semophore )` ：
          <br />信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

          <br />`信号 ( sinal )` ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

          <br />`共享内存( shared memory )` ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC
          方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

          <br />`套接字( socket ) 通信`： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信
          <hr /> 浏览器样式兼容
          一、CSS初始化<br />
          每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是对其进行初始化（覆盖默认样式）<br />
          常见 :  *{ margin: 0; padding: 0;}<br />
          库：normalize.css<br />

          <hr /> 二、浏览器私有属性<br />

          常用的前缀有：<br />
          firefox浏览器 ：-moz-<br />
          chrome、safari ：-webkit-<br />
          opera ：-o- / -xv-<br />
          IE浏览器 ：-ms-（目前只有 IE 8+支持）<br />
          三、CSS hack（条件hack、属性级hack、选择符级hack）<br />
          <hr />
          <p><a href="#ljhs" name="ljhs" class="h4">JS垃圾回收机制</a></p>

          <br />1. 项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。

          <br />2. 浏览器垃圾回收机制/内存回收机制:

          <br /> 浏览器的`Javascript`具有自动垃圾回收机制(`GC:Garbage Collecation`)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。

          <br />标记清除:在`js`中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间。
          <br />谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。
          <br />IE浏览器：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。

          <br />1. 优化手段：内存优化 ; 手动释放：取消内存的占用即可。

          <br />（1）堆内存：fn = null 【null：空指针对象】

          <br />（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。

          <br />1. 内存泄漏

          <br />在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器
          <hr />
          <a href="#typescript1" name="typescript1" class="h4">1、什么是TypeScript？</a>
          <p>TypeScript是JavaScript的加强版，它给JavaScript添加了可选的静态类型和基于类的面向对象编程，它拓展了JavaScript的语法。</p>
          <p>而且TypeScript不存在跟浏览器不兼容的问题，因为在编译时，它产生的都是JavaScript代码。</p>
          <hr />
          <a href="#typescript2" name="typescript2" class="h4">2、TypeScript 和 JavaScript 的区别是什么？</a>
          <p>Typescript 是 JavaScript 的超集，可以被编译成 JavaScript 代码。 用 JavaScript 编写的合法代码，在 TypeScript 中依然有效。Typescript
            是纯面向对象的编程语言，包含类和接口的概念。 程序员可以用它来编写面向对象的服务端或客户端程序，并将它们编译成 JavaScript 代码。
          </p>
          <h5>TypeScript和 JavaScript的关系</h5>
          <h6>TypeScript 引入了很多面向对象程序设计的特征，包括：</h6>
          <ul>
            <li>interfaces 接口</li>
            <li>classes 类</li>
            <li>enumerated types 枚举类型</li>
            <li>generics 泛型</li>
            <li>modules 模块</li>
          </ul>
          <h6>主要不同点如下：</h6>
          <ol>
            <li>TS 是一种面向对象编程语言，而 JS 是一种脚本语言（尽管 JS 是基于对象的）。</li>
            <li>TS 支持可选参数， JS 则不支持该特性。</li>
            <li>TS 支持静态类型，JS 不支持。</li>
            <li>TS 支持接口，JS 不支持接口。</li>
          </ol>
          <hr />
          <a href="#typescript3" name="typescript3" class="h4">3、为什么要用 TypeScript ？</a>
          <p>TS 在开发时就能给出编译错误， 而 JS 错误则需要在运行时才能暴露。</p>
          <p>作为强类型语言，你可以明确知道数据的类型。代码可读性极强，几乎每个人都能理解。</p>
          <p>TS 非常流行，被很多业界大佬使用。像 Asana、Circle CI 和 Slack 这些公司都在用 TS。</p>
          <hr />
          <a href="#typescript4" name="typescript4" class="h4">4、TypeScript 和 JavaScript 哪个更好？</a>
          <p>由于 TS 的先天优势，TS 越来越受欢迎。但是TS 最终不可能取代 JS，因为 JS 是 TS 的核心。</p>
          <p>选择 TypeScript 还是 JavaScript 要由开发者自己去做决定。如果你喜欢类型安全的语言，那么推荐你选择 TS。 如果你已经用 JS 好久了，你可以选择走出舒适区学习
            TS，也可以选择坚持自己的强项，继续使用 JS。
          </p>
          <hr />
          <a href="#typescript5" name="typescript5" class="h4">5、什么是泛型？</a>
          <p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，使用时再去指定类型的一种特性。</p>
          <p>可以把泛型理解为代表类型的参数</p>
          <p>// 我们希望传入的值是什么类型，返回的值就是什么类型</p>
          <p>// 传入的值可以是任意的类型，这时候就可以用到 泛型</p>
          <p>// 如果使用 any 的话，就失去了类型检查的意义</p>
          <p>
            function createArray1(length: any, value: any): Array&lt;any&gt; {<br />
            let result: any = [];<br />
            for (let i = 0; i &lt; length; i++) {<br />
            result[i] = value;<br />
            }<br />
            return result;<br />
            }<br />
            <br />
            let result = createArray1(3, 'x');<br />
            console.log(result);<br />
            <br />
            // 最傻的写法：每种类型都得定义一种函数<br />
            function createArray2(length: number, value: string): Array&lt;string&gt; {<br />
            let result: Array&lt;string&gt; = [];<br />
            for (let i = 0; i &lt; length; i++) {<br />
            result[i] = value;<br />
            }<br />
            return result;<br />
            }<br />

            function createArray3(length: number, value: number): Array&lt;number&gt; {<br />
            let result: Array&lt;number&gt; = [];<br />
            for (let i = 0; i &lt; length; i++) {<br />
            result[i] = value;<br />
            }<br />
            return result;<br />
            }<br />
            // 或者使用函数重载，写法有点麻烦<br />
            function createArray4(length: number, value: number): Array&lt;number&gt;<br />
            function createArray4(length: number, value: string): Array&lt;string&gt;<br />
            function createArray4(length: number, value: any): Array&lt;any&gt; {<br />
            let result: Array&lt;number&gt; = [];<br />
            for (let i = 0; i &lt; length; i++) {<br />
            result[i] = value;<br />
            }<br />
            return result;<br />
            }<br />
            createArray4(6, '666');<br />
            //使用泛型<br />
            // 有关联的地方都改成 &lt;T&gt;<br />
            function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {<br />
            let result: T[] = [];<br />
            for (let i = 0; i &lt; length; i++) {<br />
            result[i] = value;<br />
            }<br />
            return result;<br />
            }<br />
            // 使用的时候再指定类型<br />
            let result = createArray&lt;string&gt;(3, 'x');<br />
            // 也可以不指定类型，TS 会自动类型推导<br />
            let result2 = createArray(3, 'x');<br />
            console.log(result);<br />
          </p>
          <hr />
          <a href="#typescript6" name="typescript6" class="h4">6、TS中的类</a>
          <p>TypeScript 是面向对象的 JavaScript。而其中的类描述了所创建的对象共同的属性和方法。</p>
          <p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但这对于熟悉使用面向对象方式的程序员来说有些棘手，因为他们用的是基于类的继承并且对象是从类构建出来的。</p>
          <p>从ECMAScript 2015，也就是ECMAScript
            6，JavaScript程序将可以使用这种基于类的面向对象方法。在TypeScript里允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，
          </p>
          <hr />
          <a href="#typescript7" name="typescript7" class="h4">7、什么是构造函数，构造函数作用是什么？</a>
          <p>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象，
            即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。而TypeScript的构造函数用关键字constructor来实现。可以通过this（和java/C#一样代表对象实例的成员访问）关键字来访问当前类体中的属性和方法。
          </p>
          <hr />
          <a href="#typescript8" name="typescript8" class="h4">8、实例化是什么？</a>
          <p>一般情况下，创建一个类后并不能直接的对属性和方法进行引用，必须对类进行实例化，即创建一个对象。TypeScript中用new 关键字创建对象。实例化后通过“.”来访问属性和方法
          </p>
          <hr />
          <a href="#typescript9" name="typescript9" class="h4">9、方法重写是什么？</a>
          <p>子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写
          </p>
          <p>重写的作用在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。</p>
          <hr />
          <a href="#typescript10" name="typescript10" class="h4">10、什么是可索引类型接口？</a>
          <p>一般用来约束数组和对象</p>
          <p>数字索引——约束数组</p>
          <p>
            // index 是随便取的名字，可以任意取名 <br />
            // 只要 index 的类型是 number，那么值的类型必须是 string<br />
            interface StringArray {<br />
            // key 的类型为 number ，一般都代表是数组<br />
            // 限制 value 的类型为 string<br />
            [index:number]:string<br />
            }<br />
            let arr:StringArray = ['aaa','bbb'];<br />
            console.log(arr);<br />
            <br />

            // 字符串索引——约束对象<br />
            // 只要 index 的类型是 string，那么值的类型必须是 string<br />
            interface StringObject {<br />
            // key 的类型为 string ，一般都代表是对象<br />
            // 限制 value 的类型为 string<br />
            [index:string]:string<br />
            }<br />
            let obj:StringObject = {name:'ccc'};<br />
          </p>
          <hr />
          <a href="#typescript11" name="typescript11" class="h4">11、什么是函数类型接口？</a>
          <p>对方法传入的参数和返回值进行约束</p>
          <p>
            // 注意区别 <br />
            // 普通的接口<br />
            interface discount1{<br />
            getNum : (price:number) => number<br />
            }<br />
            <br />
            // 函数类型接口<br />
            interface discount2{<br />
            // 注意:<br />
            // “:” 前面的是函数的签名，用来约束函数的参数<br />
            // ":" 后面的用来约束函数的返回值<br />
            (price:number):number<br />
            }<br />
            let cost:discount2 = function(price:number):number{<br />
            return price * .8;<br />
            }<br />
            <br />
            // 也可以使用类型别名<br />
            type Add = (x: number, y: number) => number<br />
            let add: Add = (a: number, b: number) => a + b<br />
          </p>
          <hr />
          <a href="#typescript12" name="typescript12" class="h4">12、什么是类类型接口？</a>
          <p>如果接口用于一个类的话，那么接口会表示“行为的抽象”</p>
          <p>对类的约束，让类去实现接口，类可以实现多个接口</p>
          <p>接口只能约束类的公有成员（实例属性/方法），无法约束私有成员、构造函数、静态属性/方法</p>
          <p>
            // 接口可以在面向对象编程中表示为行为的抽象 <br />
            interface Speakable {<br />
            name: string;<br />
            <br />
            // ":" 前面的是函数签名，用来约束函数的参数<br />
            // ":" 后面的用来约束函数的返回值<br />
            speak(words: string): void<br />
            }<br />

            interface Speakable2 {<br />
            age: number;<br />
            }<br />

            class Dog implements Speakable, Speakable2 {<br />
            name!: string;<br />
            age = 18;<br />
            <br />
            speak(words: string) {<br />
            console.log(words);<br />
            }<br />
            }<br />
            <br />
            let dog = new Dog();<br />
            dog.speak('汪汪汪');<br />
          </p>
          <hr />
          <a href="#typescript13" name="typescript13" class="h4">13、什么是混合类型接口？</a>
          <h6>一个对象可以同时做为函数和对象使用</h6>
          <p>
            interface FnType {<br />
            (getName:string):string;<br />
            }<br />
            <br />
            interface MixedType extends FnType{<br />
            name:string;<br />
            age:number;<br />
            }<br />
            interface Counter {<br />
            (start: number): string;<br />
            interval: number;<br />
            reset(): void;<br />
            }

            function getCounter(): Counter {<br />
            let counter = &lt;Counter&gt;function (start: number) { };<br />
            counter.interval = 123;<br />
            counter.reset = function () { };<br />
            return counter;<br />
            }<br />

            let c = getCounter();<br />
            c(10);<br />
            c.reset();<br />
            c.interval = 5.0;<br />
          </p>
          <hr />
          <a href="#typescript14" name="typescript14" class="h4">14、never 和 void 的区别？</a>
          <p>void 表示没有任何类型（可以被赋值为 null 和 undefined）。</p>
          <p>never 表示一个不包含值的类型，即表示永远不存在的值。</p>
          <p class="text-danger">拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。</p>
          <hr />
          <a href="#typescript15" name="typescript15" class="h4">15、TS的学前基础？</a>
          <p>因为 TypeScript 是对 JavaScript 的扩展，更准确的说是 ECMAScript。所以，我们学习我们这套 TypeScript 的课程，需要具备 ECMAScript 语言的基础：
          </p>
          <ol>
            <li>
              熟悉语法基础（变量、语句、函数等基础概念）</li>
            <li>掌握内置对象（Array、Date 等）的使用</li>
            <li>面向对象基本概念（构造函数、原型、继承）</li>
          </ol>
        </div>
      </main>
    </div>
  </div>
</body>

</html>