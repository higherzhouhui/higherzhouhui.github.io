<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Mark Otto, Jacob Thornton, and Bootstrap contributors">
  <meta name="generator" content="Hugo 0.88.1">
  <title>REACT</title>

  <link rel="canonical" href="https://getbootstrap.com/docs/5.1/examples/dashboard/">

  <!-- Bootstrap core CSS -->
  <link href="../css/bootstrap.min.css" rel="stylesheet">

  <style>
    .bd-placeholder-img {
      font-size: 1.125rem;
      text-anchor: middle;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    @media (min-width: 768px) {
      .bd-placeholder-img-lg {
        font-size: 3.5rem;
      }
    }

    a {
      text-decoration: none;
    }

    .sidebar {
      overflow: auto;
    }
  </style>


  <!-- Custom styles for this template -->
  <link href="../css/dashboard.css" rel="stylesheet">
</head>

<body>
  <div class="container-fluid">
    <div class="row">
      <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block bg-light sidebar collapse">
        <div class="position-sticky pt-3">
          <ul class="nav flex-column">
            <li class="nav-item">
              <a class="nav-link h4" aria-current="page" href="/">
                <span data-feather="home"></span>
                首页->React
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link h6" aria-current="page" href="#r1">
                <span data-feather="home"></span>
                React介绍
              </a>
              <ul>
                
                <li>
                  <a class="nav-link" aria-current="page" href="#hooks">
                    <span data-feather="home"></span>
                    Hooks的优缺点
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#r2">
                    <span data-feather="home"></span>
                    聊聊react中class组件和函数组件的区别
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#r3">
                    <span data-feather="home"></span>
                    React Hooks（钩子的作用）
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#r4">
                    <span data-feather="home"></span>
                    React 组件通信方式
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#redux">
                    <span data-feather="home"></span>
                    Redux相关
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#r5">
                    <span data-feather="home"></span>
                    setState 既存在异步情况也存在同步情况
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#r6">
                    <span data-feather="home"></span>
                    生命周期
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#r7">
                    <span data-feather="home"></span>
                    说一下 react-fiber
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#r8">
                    <span data-feather="home"></span>
                    Portals
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#r9">
                    <span data-feather="home"></span>
                    何时要使用异步组件？如和使用异步组件
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#r10">
                    <span data-feather="home"></span>
                    React 事件绑定原理
                  </a>
                </li>
                <li>
                  <a class="nav-link" aria-current="page" href="#r11">
                    <span data-feather="home"></span>
                    React.lazy()实现的原理
                  </a>
                </li>
              </ul>
            </li>
          </ul>
        </div>
      </nav>
      <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
        <div class="pt-3 pb-3 mb-3">
          <a href="#r1" name="r1" class="h4">React介绍</a>
          <p class="mt-2 mb-2 h6">React就是Facebook的一个开源JS框架，专注的层面为View层，不包括数据访问层或者那种Hash路由（不过React
            有插件支持），与Angularjs，Emberjs等大而全的框架不同，React专注的中心是Component，即组件。React认为一切页面元 素都可以抽象成组件，比如一个表单，或者表单中的某一项。
          </p>
          <p class="h6">
            React可以作为MVVM中第二个V，也就是View，但是并不是MVVM框架。MVVM一个最显著的特征：双向绑定。React没有这个，它是单向数据绑定的。React是一个单向数据流的库，状态驱动视图。react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流，推崇结合immutable来实现数据不可变。
          </p>
          <hr />
          <a href="#hooks" name="hooks" class="h4">Hooks的优缺点</a>
          <h5>优点</h5>
          <ol>
            <li>代码的可读性强，在使用hooks之前比如发布/订阅自定义事件被挂载在componentDidMount生命周期中，然后需要在componentWillUnmount生命周期中将它清楚，这样就不便于开发者维护和迭代。在使用hooks之后，通过useEffect可以将componentDidMount生命周期、componentDidUpdate生命周期和componentWillUnmount生命周期聚合起来，方便代码的维护。</li>
            <li>组件层级变得更浅了，在使用hooks之前通常使用高阶组件HOC的方法来复用多个组件公共的状态，增强组建的功能，这样肯定是加大了组件渲染的开销，损失了性能。但是在hooks中可以通过自定义组件useXxx()的方法将多个组件之间的共享逻辑放在自定义hook中，就可以轻松的进行数据互通。</li>
            <li>不再需要考虑class组件中this指向的问题，hook在函数组件中不需要通过this.state或者this.fn来获取数据或者方法。 </li>
          </ol>
          <h5>缺点</h5>
          <ol>
            <li>hooks的useEffect只包括了componentDidMount、componentDidUpdate还有componentWillUnmount这三个生命周期，对于getSnapshotBeforeUpdate和componentDidCatch等其他的生命周期没有支持。</li>
            <li>使用useEffect时候里面不能写太多依赖项，将各个不同的功能划分为多个useEffect模块，将各项功能拆开写，这是遵循了软件设计的“单一职责模式”。如果遇到状态不同步的情况，使用手动传递参数的形式。</li>
            <li>如果业务复杂，就使用Component代替hooks，hooks的出现并不是取代了class组件，而是在函数组件的基础上可以实现一部分的类似class组件功能。</li>
          </ol>
          <hr />
          <a href="#r2" name="r2" class="h4">聊聊react中class组件和函数组件的区别</a>
          <p>类组件是使用ES6 的 class 来定义的组件。 函数组件是接收一个单一的 `props` 对象并返回一个React元素。</p>
          <p>关于React的两套API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较"轻"，而类比较"重"。而且，钩子是函数，更符合
            React 函数式的本质。
          </p>
          <p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML
            代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。
          </p>
          <h5>类（class）是数据和逻辑的封装。</h5>
          <p>也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个class 里面。</p>
          <h5>类组件的缺点</h5>
          <ol>
            <li>大型组件很难拆分和重构，也很难测试。</li>
            <li>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li>
            <li>组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li>
            <li>难以理解的 class，理解 JavaScript 中 `this` 的工作方式。</li>
          </ol>
          <h5>区别</h5>
          <h6>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</h6>
          <ol>
            <li>状态的有无
              <p>hooks出现之前，函数组件`没有实例`，`没有生命周期`，`没有state`，`没有this`，所以我们称函数组件为无状态组件。
                hooks出现之前，react中的函数组件通常只考虑负责UI的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数props决定，不受其他任何因素影响。
              </p>
            </li>
            <li>调用方式的不同
              <p>函数组件重新渲染，将重新调用组件方法返回新的react元素。类组件重新渲染将new一个新的组件实例，然后调用render类方法返回react元素，这也说明为什么类组件中this是可变的。</p>
            </li>
            <li>因为调用方式不同，在函数组件使用中会出现问题
              <p>在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值</p>
            </li>
          </ol>
          <hr />
          <a href="#r3" name="r3" class="h4">React Hooks（钩子的作用）</a>
          <h5>*Hook* 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
          </h5>
          <ul>
            <li>`useState()` //状态钩子</li>
            <li>`useContext()` //共享状态钩子</li>
            <li>`useReducer()` //action 钩子</li>
            <li>`useEffect()` //副作用钩子</li>
            <li>useCallback 记忆函数
              <p>一般把**函数式组件理解为class组件render函数的语法糖**，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过
                useCallback 获得一个记忆后的函数。</p>
              <p>
                ```js <br />
                function App() {<br />
                const memoizedHandleClick = useCallback(() => {<br />
                console.log('Click happened')<br />
                }, []); // 空数组代表无论什么情况下该函数都不会发生改变<br />
                return &lt;SomeComponent onClick={memoizedHandleClick}&gt;Click Me&lt;/SomeComponent&gt;;<br />
                }<br />
                ```<br />
                第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。<br />
              </p>
            </li>
            <li>useMemo 记忆组件
              <p>useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 唯一的区别是：**useCallback
                不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你</p>
              <p>所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p>
            </li>
            <li>useRef 保存引用值
              <p>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值**访问组件或真实的
                DOM 节点，重点是组件也是可以访问到的**，从而可以对 DOM 进行一些操作，比如监听事件等等</p>
            </li>
            <li>useImperativeHandle 穿透 Ref
              <p>通过 useImperativeHandle 用于让父组件获取子组件内的索引</p>
            </li>
            <li>
              useLayoutEffect 同步执行副作用
              <p>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect
                中的副作用会在 DOM 更新之后同步执行。</p>
            </li>
          </ul>
          <h6>useEffect和useLayoutEffect有什么区别</h6>
          <p>
            简单来说就是调用时机不同，useLayoutEffect和原来componentDidMount&componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。`官方建议优先使用useEffect
          </p>
          <hr />
          <a href="#redux" name="redux" class="h4">Redux介绍</a>
          <h5>什么是Redux</h5>
          <p>redux是专门用于集中式管理状态的javascript库
          </p>
          <h5>Redux工作流程</h5>
          <h6>分别为actions、store、reducers（带s的表明可能存在多个）
          </h6>
          <ol>
            <li>让Action Creators创建action</li>
            <li>通过dispatch将action分发出去</li>
            <li>store对要使用的reducer进行绑定，然后将action分发到对应的reducer上</li>
            <li>在reducer上进行相应的action操作并返回结果给store</li>
            <li>组件就可以通过store的API像store进行获取操作返回的结果</li>
          </ol>
          <hr />
          <a href="#r4" name="r4" class="h4">React 组件通信方式</a>
          <h5>react组件间通信常见的几种情况</h5>
          <ol>
            <li>父组件向子组件通信
              <p>
                父组件通过 props 向子组件传递需要的信息。父传子是在父组件中直接绑定一个正常的属性，这个属性就是指具体的值，在子组件中，用props就可以获取到这个值
                <br />```js
                <br />// 子组件: Child
                <br />const Child = props =>{
                <br />&nbsp;&nbsp; return {props.name}
                <br />}
                <br />
                <br />// 父组件 Parent
                <br />const Parent = ()=>{
                <br /> &nbsp;&nbsp;return &lt;Child name="京程一灯"&gt;&lt;/Child&gt;
                <br />}
                <br /> ```
              </p>
            </li>
            <li>子组件向父组件通信
              <p>
                props+回调的方式，使用公共组件进行状态提升。子传父是先在父组件上绑定属性设置为一个函数，当子组件需要给父组件传值的时候，则通过props调用该函数将参数传入到该函数当中，此时就可以在父组件中的函数中接收到该参数了，这个参数则为子组件传过来的值
                <br /> ```js
                <br />// 子组件: Child
                <br />const Child = props =>{
                <br /> &nbsp;&nbsp;const cb = msg =>{
                <br /> &nbsp;&nbsp;&nbsp;&nbsp;return ()=>{
                <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;props.callback(msg)
                <br /> &nbsp;&nbsp;&nbsp;&nbsp;}
                <br /> &nbsp;&nbsp;}
                <br />&nbsp;&nbsp;return (
                <br /> &nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={cb("京程一灯欢迎你!")}>京程一灯欢迎你&lt;/button&gt;
                <br /> &nbsp;&nbsp;)
                <br /> }
                <br />
                <br />// 父组件 Parent
                <br />class Parent extends Component {
                <br /> &nbsp;&nbsp;callback(msg){
                <br /> &nbsp;&nbsp;&nbsp;&nbsp;console.log(msg)
                <br /> &nbsp;&nbsp;}
                <br /> &nbsp;&nbsp;render(){
                <br /> &nbsp;&nbsp;&nbsp;&nbsp;return &lt;Child callback={this.callback.bind(this)}&gt;&lt;/Child&gt;
                <br /> &nbsp;&nbsp;}
                <br /> }
                <br /> ```
              </p>
            </li>
            <li>跨级组件通信
              <p>
              <p>即父组件向子组件的子组件通信，向更深层子组件通信。</p>
              <p> 使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。
              </p>
              <p>使用context，context相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。</p>
              ```js
              <br />// context方式实现跨级组件通信
              <br />// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据
              <br />
              <br />const BatteryContext = createContext();
              <br />
              <br />// 子组件的子组件
              <br />class GrandChild extends Component {
              <br />&nbsp;&nbsp;render(){
              <br />&nbsp;&nbsp;&nbsp;&nbsp;return (
              <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BatteryContext.Consumer&gt;
              <br />&nbsp;&nbsp;&nbsp;&nbsp;{
              <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color => &lt;h1
              style={{"color":color}}&gt;我是红色的:{color}&lt;/h1&gt;
              <br />&nbsp;&nbsp;&nbsp;&nbsp;}
              <br />&lt;/BatteryContext.Consumer&gt;
              <br />&nbsp;&nbsp;&nbsp;&nbsp;)
              <br />&nbsp;&nbsp;}
              <br />}
              <br />
              <br /> // 子组件
              <br />const Child = () =>{
              <br /> &nbsp;&nbsp;return (
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&lt;GrandChild /&gt;
              <br />&nbsp;&nbsp;)
              <br />}
              <br />// 父组件
              <br />class Parent extends Component {
              <br />&nbsp;&nbsp;state = {
              <br />&nbsp;&nbsp;&nbsp;&nbsp;color:"red"
              <br /> &nbsp;&nbsp;}
              <br />&nbsp;&nbsp;render(){
              <br />&nbsp;&nbsp;&nbsp;&nbsp;const {color} = this.state
              <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (
              <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BatteryContext.Provider value={color}&gt;
              <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Child&gt;&lt;/Child&gt;
              <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BatteryContext.Provider &gt;<br />
              &nbsp;&nbsp;&nbsp;&nbsp; )
              <br />&nbsp;&nbsp;}
              <br />}
              <br />```
              </p>
            </li>
            <li>非嵌套关系的组件通信
              <p>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</p>
              <ol>
                <li>可以使用自定义事件通信（发布订阅模式），使用pubsub-js</li>
                <li>可以通过redux等进行全局状态管理</li>
                <li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li>
                <li>也可以new一个 NODE 的 EventBus,进行事件监听，一边执行监听，一边执行新增 NODE的eventBus 就是发布订阅模式，是可以在React中使用的;</li>
              </ol>
            </li>
          </ol>
          <hr />
          <a href="#r5" name="r5" class="h4">setState 既存在异步情况也存在同步情况</a>
          <h5>1.异步情况 在`React事件当中是异步操作`</h5>
          <h5>2.同步情况 如果是在`setTimeout事件或者自定义的dom事件`中，都是同步的</h5>
          <p>
            ```js
            <br />//setTimeout事件
            <br />import React,{ Component } from "react";
            <br />class Count extends Component{
            <br />&nbsp;&nbsp;constructor(props){
            <br />&nbsp;&nbsp;&nbsp;&nbsp;super(props);
            <br />&nbsp;&nbsp;&nbsp;&nbsp;this.state = {
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count:0
            <br />&nbsp;&nbsp;&nbsp;&nbsp;}
            <br />&nbsp;&nbsp;}

            <br />&nbsp;&nbsp;render(){
            <br />&nbsp;&nbsp;&nbsp;&nbsp;return (
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;count:{this.state.count}&lt;/p&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button
            onClick={this.btnAction}&gt;增加&lt;/button&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;)
            <br />&nbsp;&nbsp;}

            <br />&nbsp;&nbsp;btnAction = ()=>{
            <br />&nbsp;&nbsp;//不能直接修改state，需要通过setState进行修改
            <br />&nbsp;&nbsp;//同步
            <br />&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(()=>{
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setState({
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count: this.state.count + 1
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.state.count);
            <br />&nbsp;&nbsp;&nbsp;&nbsp;})
            <br /> &nbsp;&nbsp;}
            <br />}
            <br />
            <br />export default Count;
            <br />```

            <br />```js
            <br />//自定义dom事件
            <br />import React,{ Component } from "react";
            <br />class Count extends Component{
            <br />&nbsp;&nbsp;constructor(props){
            <br />&nbsp;&nbsp;&nbsp;&nbsp;super(props);
            <br />&nbsp;&nbsp;&nbsp;&nbsp;this.state = {
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count:0
            <br />&nbsp;&nbsp;&nbsp;&nbsp;}
            <br />&nbsp;&nbsp;}
            <br />
            <br />&nbsp;&nbsp;render(){
            <br />&nbsp;&nbsp;&nbsp;&nbsp;return (
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;count:{this.state.count}&lt;/p&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button id="btn"&gt;绑定点击事件&lt;/button&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;/&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;)
            <br />&nbsp;&nbsp;&nbsp;&nbsp;}
            <br />
            <br />&nbsp;&nbsp;componentDidMount(){
            <br />//自定义dom事件，也是同步修改
            <br />&nbsp;&nbsp;&nbsp;&nbsp;document.querySelector('#btn').addEventListener('click',()=>{
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.setState({
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count: this.state.count + 1
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.state.count);
            <br />&nbsp;&nbsp;&nbsp;&nbsp;});
            <br />&nbsp;&nbsp;}
            <br />}
            <br />
            <br />export default Count;
            <br /> ```
          </p>
          <hr />
          <a href="#r6" name="r6" class="h4">生命周期</a>
          <h5>安装</h5>
          <h6> 当组件的实例被创建并插入到 DOM 中时，这些方法按以下顺序调用：
          </h6>
          <ol>
            <li>constructor()</li>
            <li>static getDerivedStateFromProps()</li>
            <li>render()</li>
            <li>componentDidMount()</li>
          </ol>

          <h5>更新中</h5>
          <h6> 更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：
          </h6>
          <ol>
            <li>static getDerivedStateFromProps()</li>
            <li>shouldComponentUpdate()</li>
            <li>render()</li>
            <li>getSnapshotBeforeUpdate()</li>
            <li>componentDidUpdate()
            </li>
          </ol>
          <h5>卸载</h5>
          <h6> 当组件从 DOM 中移除时调用此方法：
          </h6>
          <p>componentWillUnmount()</p>
          <hr />
          <a href="#r7" name="r7" class="h4">说一下 react-fiber</a>
          <h5>1）背景</h5>
          <h6>react-fiber 产生的根本原因，是`大量的同步计算任务阻塞了浏览器的 UI 渲染`。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS
            运算持续占用主线程，页面就没法得到及时的更新。当我们调用`setState`更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16
            毫秒，就容易出现掉帧的现象。</h6>
          <h5>2）实现原理</h5>
          <h6>react内部运转分三层：</h6>
          <ol>
            <li>Virtual DOM 层，描述页面长什么样。</li>
            <li>Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li>
            <li>Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li>
          </ol>
          <p class="text-danger">Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示</p>
          <p>
            ```js
            <br />const fiber = {
            <br />&nbsp;&nbsp;stateNode, // 节点实例
            <br />&nbsp;&nbsp;child, // 子节点
            <br />&nbsp;&nbsp;sibling, // 兄弟节点
            <br />&nbsp;&nbsp;return, // 父节点
            <br />}
            <br />```
            <br />
          <p>为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：</p>
          <ol>
            <li>synchronous，与之前的Stack Reconciler操作一样，同步执行</li>
            <li>task，在next tick之前执行</li>
            <li>animation，下一帧之前执行</li>
            <li>high，在不久的将来立即执行</li>
            <li>low，稍微延迟执行也没关系</li>
            <li>offscreen，下一次render时或scroll时才执行</li>
          </ol>
          <h6>Fiber Reconciler（react ）执行过程分为2个阶段：</h6>
          <p>生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</p>
          <p>将需要更新的节点一次过批量更新，这个过程不能被打断。</p>

          <h6> Fiber树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了
            Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree
            一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合
            requestIdleCallback API, 实现任务拆分、中断与恢复。</h6>
          <p class="text-danger">从Stack Reconciler到Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情</p>
          <p class="text-success">传送门 ☞[# 深入了解 Fiber](https://juejin.cn/post/7002250258826657799)</p>
          </p>
          <hr />
          <a href="#r8" name="r8" class="h4">Portals</a>
          <h5>Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用portals进行创建
          </h5>
          <hr />
          <a href="#r9" name="r9" class="h4">何时要使用异步组件？如和使用异步组件</a>
          <ol>
            <li>加载大组件的时候</li>
            <li>路由异步加载的时候</li>
          </ol>
          <h5>react 中要配合 Suspense 使用</h5>
          <p>
            ```js
            <br />// 异步懒加载
            <br />const Box = lazy(()=>import('./components/Box'));
            <br />&nbsp;&nbsp;// 使用组件的时候要用suspense进行包裹
            <br />&nbsp;&nbsp;&lt;Suspense fallback={&lt;div&gt;loading...
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;}>
            <br />&nbsp;&nbsp;&lt;/Suspense&gt;
            <br />```
          </p>
          <hr />
          <a href="#r10" name="r10" class="h4"> React 事件绑定原理</a>
          <p>
            React并不是将click事件绑在该div的真实DOM上，而是`在document处监听所有支持的事件`，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。
          </p>
          <p> 另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用
            event.stopPropagation是无效的，而应该调用 `event.preventDefault`
          </p>
          <hr />
          <a href="#r11" name="r11" class="h4"> React.lazy()实现的原理</a>
          <h5>React的懒加载示例：</h5>
          <p>
            ``js
            <br />import React, { Suspense } from 'react';
            <br />
            <br />const OtherComponent = React.lazy(() => import('./OtherComponent'));
            <br />
            <br />function MyComponent() {
            <br />&nbsp;&nbsp;return (
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Suspense fallback={&lt;div&gt;Loading...
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;}&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;OtherComponent /&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Suspense&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
            <br />&nbsp;&nbsp;&nbsp;&nbsp;);
            <br />}
            <br />```
          </p>
          <p class="text-danger">
            至此，我们分析完了 React 的懒加载原理。简单来说，React利用 React.lazy与import()实现了渲染时的动态加载
            ，并利用Suspense来处理异步加载资源时页面应该如何显示的问题。
          </p>
          <p class="text-success">参考传送门☞ [React Lazy 的实现原理](https://thoamsy.github.io/blogs/react-lazy/)</p>
        </div>
      </main>
    </div>
  </div>
</body>

</html>